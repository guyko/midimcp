# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Kotlin-based Maven project called "midimcp" - a local MCP (Model Context Protocol) server that manages MIDI guitar pedal execution. The server provides persistent knowledge of pedal parameters and executes MIDI CC commands generated by AI assistants. The AI assistant handles natural language interpretation while the MCP server focuses on command execution and pedal management.

## Build Commands

- **Build project**: `mvn compile`
- **Run MCP server**: `mvn exec:java` or `./run-server.sh`
- **Run tests**: `mvn test`
- **Package**: `mvn package`
- **Clean**: `mvn clean`

## Project Architecture

### Core Components

1. **Data Models** (`src/main/java/com/guyko/models/`)
   - `PedalModel`: Represents a guitar pedal with its MIDI CC mappings
   - `CCParameter`: Represents individual MIDI CC parameters (name, CC number, value ranges)
   - `MidiCommand`: Represents generated MIDI commands with byte conversion

2. **MIDI Execution** (`src/main/java/com/guyko/midi/`)
   - `MidiExecutor`: Interface for MIDI command execution
   - `HardwareMidiExecutor`: Real hardware MIDI output
   - `MockMidiExecutor`: Testing implementation with command tracking

3. **Persistence Layer** (`src/main/java/com/guyko/persistence/`)
   - `PedalRepository`: JSON-based storage for pedal configurations using Gson
   - Data stored in `data/pedals/` directory as JSON files

4. **MCP Server** (`src/main/java/com/guyko/mcp/`)
   - `MCPServer`: Main MCP protocol implementation with JSON-RPC communication
   - Handles tool calls for pedal management and MIDI command execution

5. **Pedal Configurations** (`src/main/java/com/guyko/pedals/`)
   - `MerisLVXLoader`: Pre-configured Meris LVX delay pedal with full CC table
   - `MerisMercuryXLoader`: Pre-configured Meris Mercury X reverb pedal with full CC table
   - `MerisEnzoXLoader`: Pre-configured Meris Enzo X synthesizer pedal with full CC table

### Available MCP Tools

- `add_pedal`: Add new guitar pedals with MIDI CC mappings
- `get_pedal`: Retrieve specific pedal information
- `list_pedals`: List all available pedals
- `execute_midi_command`: Execute a single MIDI CC command on a pedal
- `execute_midi_commands`: Execute multiple MIDI CC commands in sequence to create presets
- `execute_program_change`: Switch pedal presets via MIDI program change
- `send_sysex`: Send sysex data directly to a MIDI device for preset uploads or custom messages
- `get_midi_status`: Get MIDI executor connection status
- `rescan_midi_devices`: Re-scan for MIDI devices (useful if devices were connected after server startup)

### Architecture Design

**MCP Server Responsibilities:**
- Pedal knowledge storage and retrieval (CC mappings, parameter descriptions)
- Exposes pedal configurations via MCP tools (get_pedal, list_pedals)
- MIDI command validation and execution
- Hardware communication and command result reporting
- Real-time preset creation via multiple CC commands

**AI Assistant Responsibilities:**
- Query MCP server for pedal configurations and capabilities
- Natural language interpretation using exposed pedal knowledge
- Translate user requests ("make it brighter") to specific MIDI commands using CC mappings
- Musical knowledge and sound design decisions based on pedal parameters
- Create presets by sending multiple CC commands that user can then save on pedal

### Preset Creation System

The server creates presets by sending multiple MIDI CC commands in real-time:

**Supported Pedals:**
- **LVX Delay**: Complete delay preset creation with all processing elements
- **Mercury X Reverb**: Full reverb preset creation with all 8 reverb structures  
- **Enzo X Synthesizer**: Complete synthesizer preset creation with all synth modes

**Architecture:**
- Uses standard MIDI CC commands (no complex sysex)
- Real-time parameter changes that user hears immediately
- User saves the preset manually on the pedal when satisfied
- All CC mappings are documented and validated

**Workflow:**
1. AI assistant queries MCP server for pedal CC mappings and capabilities
2. AI translates natural language ("warm vintage delay") to specific CC parameter values
3. AI calls `execute_midi_commands` tool with multiple CC commands
4. MCP server sends all CC commands in sequence to the pedal
5. User hears the preset in real-time and saves it manually on the pedal

### Understanding Pedal Architectures

Each Meris pedal has a unique architecture that AI assistants must understand to create appropriate presets:

#### Mercury X Reverb - PREDELAY + REVERB TANK Architecture
- **NOT a traditional delay pedal** - uses predelay system feeding into reverb algorithms
- **Predelay**: Early reflections (CC15=time, CC16=type, CC19=feedback, CC21=modulation)
- **Reverb Tank**: 8 different algorithms (CC32=structure: Ultraplate, Cathedra, Spring, 78 Room/Plate/Hall, Prism, Gravity)
- **Key Insight**: "Delay" settings affect predelay reflections, not standalone delay repeats
- **Common Mistake**: Treating CC15 as traditional delay time - it's predelay timing for early reflections

#### LVX Delay - TRUE DELAY Architecture  
- **Traditional delay pedal** with multiple engines and extensive modulation
- **Delay Engines**: Digital, BBD (analog), Tape (CC16=engine type)
- **Core Controls**: Time (CC15), Feedback (CC19), Mix (CC1), Modulation (CC21)
- **Key Insight**: Creates actual delay repeats with configurable feedback trails
- **Timing**: CC15 directly controls delay repeat timing (0≈1ms, 64≈400ms, 127≈2sec)

#### Enzo X Synthesizer - GUITAR TRACKING SYNTHESIZER
- **Guitar-to-MIDI synthesizer** that tracks playing and generates synth sounds
- **Synth Modes**: CC22 determines tracking (Mono/Poly/Arp/Dry combinations)
- **Dual Oscillators**: CC24/25 control wave shapes (Sawtooth/Triangle/Square)
- **Filter System**: CC39=frequency (tone), CC41=resonance (character)
- **Envelopes**: CC55=amp attack (critical for pad vs lead sounds)
- **Key Insight**: NOT an effects pedal - creates synthesizer sounds from guitar input
- **Common Mistake**: Treating as delay/reverb - it's a synth engine with guitar tracking

#### Neural DSP Quad Cortex - MULTI-EFFECTS PROCESSOR
- **Complete amp/effect modeling system** with 4 independent signal paths
- **Scene/Preset Management**: Multiple operation modes with comprehensive MIDI control
- **Footswitch Control**: 8 assignable footswitches with individual bypass states
- **Expression Control**: Advanced expression pedal routing and assignment

### AI Assistant Guidelines

When creating presets, AI assistants should:

1. **Identify Pedal Type**: Understand whether you're working with delay, reverb, synthesizer, or multi-effects
2. **Use Correct Terminology**: 
   - Mercury X: "predelay time" not "delay time"
   - LVX: "delay time" for actual repeats
   - Enzo X: "synth mode" and "tracking" not "effects"
3. **Set Core Parameters First**: Each pedal has essential parameters that define its character
4. **Understand Value Ranges**: Many parameters have specific value ranges for different modes
5. **Consider Musical Context**: Match parameter choices to musical style and intended use

## Dependencies

- Kotlin 1.3.0 standard library (JDK8)
- Gson 2.8.9 for JSON serialization
- kotlin-logging for logging
- JUnit 4.12 for testing
- Mockito for mocking

## Testing

The project includes comprehensive tests covering the complete workflow:

- **Unit Tests**: Individual component testing (MIDI commands, pedal models, MIDI execution)
- **Integration Tests**: End-to-end workflow testing from AI commands to MIDI output
- **Test Coverage**: 25 focused tests covering all major functionality

Run tests with: `mvn test`

### Test Examples

The tests demonstrate the AI assistant → MCP server execution flow:

1. **AI interprets**: "make it brighter" → AI generates: `MidiCommand(channel=1, cc=5, value=100)`
2. **MCP executes**: Command validation → Hardware execution → Result: `B0 05 64` bytes sent
3. **Batch commands**: AI sends multiple commands → MCP executes sequence → All results reported

Tests include both successful execution and failure scenarios with mock hardware.

### Key Usage Example: Microcosm-Style LVX Preset

**User Request:** "I'd be happy to help you program your LVX to behave like a Microcosm pedal!"

**AI Response Highlights:**
- Configured **Poly delay structure** for granular-style processing
- Used **BBD engine** for analog warmth, **~600ms delay time** for ambient textures
- Applied **Granulize modulation** in feedback loop for Microcosm-style granular effects
- Set **complex rhythmic timing** (left=triplet quarter, right=dotted eighth)
- Added **Poly Chroma pitch shifting** and **State Variable filter** for character
- Result: **78% wet mix** ambient preset with granular clouds and stereo textures

**Technical Implementation:**
- AI queried pedal parameters via MCP tools
- Translated "Microcosm-style" to specific LVX CC commands
- Executed multiple MIDI commands to create complete preset
- User heard results in real-time and could save manually on pedal

This demonstrates the system's ability to interpret complex musical requests and translate them into precise MIDI parameter changes using pedal-specific knowledge.

## Getting Started

1. Build the project: `mvn compile`
2. Run tests: `mvn test`
3. Run the MCP server: `mvn exec:java`
4. The server will start with pre-loaded Meris pedal configurations:
   - LVX Delay (Channel 2)
   - Mercury X Reverb (Channel 1) 
   - Enzo X Synthesizer (Channel 3)
   - Quad Cortex (Channel 4)
5. Connect your AI assistant to interact via MCP protocol

## Development Environment

- IntelliJ IDEA project configuration includedq
- Maven build system with Kotlin compilation
- Git configuration with appropriate ignores for Maven/IntelliJ artifacts